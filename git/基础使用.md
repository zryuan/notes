## 初始化仓库

命令：==git init==

在执行该命令的当前目录下创建一个仓库，本质上是在该目录下创建一个==.git==目录

==.git==目录保存了在项目目录下所有提交的文件的文件操作，方便git进行版本管理操作

## 全局配置仓库

命令：==git config --global==

查看和进行全局的git配置

1. git config --global ==user.name <用户名>==：查看或者全局配置git 提交用户名
2. git config --global ==user.email <邮箱>==：查看或者全局配置git 提交用户邮箱

## 查看文件状态

命令：==git status==

查看项目目录下的文件状态

1. untracked files：表示未追踪文件，没有被git进行追踪管理（创建新增文件）
2. 已修改：表示文件已经被git管理，并对文件内容进行修改或者文件删除，对工作区
3. 已暂存：表示修改的文件被添加到暂存区，等待提交到git仓库，对应暂存区
4. 已提交：表示文件的修改已保存到git仓库，提交保存仓库只会提交暂存区内的文件修改，对应git仓库

默认是 --long 选项，表示以长格式打印文件状态

git status ==-s（--short）== 以简短格式打印文件状态

### 文件状态标识符

**??**        表示文件未追踪

**A**        表示文件第一次被添加到暂存区，之前都是为追踪的状态

**AM **   表示文件第一次被添加到暂存区后，又对文件进行了修改，但是未添加到暂存区

   **M**    表示文件被修改，但是未添加到暂存区

**M**       表示文件被修改已添加到暂存区

**MM**    表示文件被修改后添加到暂存区后，又对文件进行了修改，但是未添加到暂存区

​    **D**    表示文件删除，未添加到暂存区

**D**        表示文件删除已添加到暂存区

**R**        表示文件重命名并添加到暂存区

大概理解，**左侧是暂存区标识颜色为绿色，右侧为工作区标识颜色为红色**

## 添加暂存

命令：==git add ==

添加指定文件到暂存区域

1. git add <文件名>：指定文件名，只添加指定文件到暂存区域
2. git add <目录>：指定目录，将该目录下的所有文件修改添加到暂存区
3. git add ==.==：将所有修改文件添加到暂存区域

## 提交暂存

命令：==git commit==

将暂存区域内的文件修改提交至仓库内进行保存

1. git commit：直接使用该命令提交会进入vim模式，要求输入该次提交的描述
2. git commit ==-m <描述>==：通过-m直接添加提交描述，无需进入vim模式进行编辑
3. git commit ==-a -m <描述>==：-a表示（add）将全部修改添加暂存，所以该命令的意思是将项目全部修改添加进暂存并直接提交，省略了==git add .==的过程。
4. git commit -m <描述> ==--amend==:  --amend 表示将这次提交和上一次提交进行合并,合并成一个提交,并使用新的提交信息
   
   注意：**只有之前已经添加过暂存的文件的修改，通过-a才生效，没有添加过暂存的文件是不会被提交到git 仓库的，所以还是需要通过git add命令先添加暂存，让git进行追踪**
   
   <br/>

## 查看日志

命令：==git log==

查看git提交日志

包括提交对象哈希、作者（用户名和邮箱）、提交日期以及提交时的描述\

命令: ==git reflog==

查看git 操作日志

## 文件删除

命令：==git rm==

删除指定文件或者目录，并将删除的文件或目录添加到暂存区（相对于其他删除文件命令或者手动删除，只多了添加暂存的操作）

1. git rm <文件名>：删除指定文件并添加暂存区
2. git rm -r <目录>：删除指定目录并添加暂存区
3. git rm ==--cache <文件名>==：删除指定文件或者目录，在工作区保留相应的副本，相当于只删除了git仓库中相应的文件和目录并取消了git 的追踪和管理
4. git rm ==-f <文件名>==：强制删除文件或目录并添加暂存区

注意：**如果对文件进行了修改，但是没有进行提交，使用git rm命令进行删除是会报错的，因为git的安全机制，没有提交进行删除是会丢失对文件的修改，不能通过git进行找回。**如果确保没有任何影响，可以通过添加-f进行强制删除，其他文件删除方法是没有这个限制的。

## 文件移动

命令：==git mv==

进行文件移动和重命名，并添加到暂存

## 查看文件修改

命令： ==git diff==

对**工作区文件与暂存区或者已提交仓库的文件内容**进行前后对比，获知文件前后修改状态。

diff规则: 如果暂存区存在该文件,则对比的是工作区与暂存区文件的不同,如果暂存区不存在该文件,则对比的是工作区和仓库文件的不同

1. git diff ==<文件名>==：查看具体某一个文件的前后修改对比
2. git diff: 查看工作区所有文件的前后修改对比
3. git diff ==--staged==：查看暂存区文件和已提交仓库文件内容的前后修改对比
4. git diff ==--staged <文件名>==: 查看暂存区指定文件和仓库文件内容的前后修改对比 

## 查看提交日志

命令：==git log==

查看当前分支提交日志

1. git log ==-p==：查看当前分支提交日志，并打印每次提交的diff内容，知道每一次提交修改的内容
2. git log ==-n==：查看当前分支最近n条提交日志
3. git log ==--oneline==：以一行的形式打印提交日志，内容包括提交的hash值和提交的描述
4. git log ==--pretty=====short/full...==：定义提交日志打印模式
5. git log ==<文件名>==：打印指定文件的提交日志
6. git log ==--all==：打印所有分支的提交日志
7. git log ==--graph==：以图形化方式打印提交日志

常用命令：git log --oneline --all --graph

## 分支操作

### 查看分支

命令：==git branch==

查看分支，分支名前带==*==表示当前所处分支

### 创建分支

命令：==git branch <分支名>==

以当前所处分支为基础检出新的分支

### 切换分支

命令：==git checkout <分支名>==

切换到指定分支

git checkout ==-b== <分支名>:  加上-b表示创建新分支,并且切换到新分支

### 合并分支

命令：==git merge <目标分支>==

合并目标分支到当前所处分支

#### 取消合并

命令：git merge ==--abort==

表示**合并过程中出现了冲突**,不想合并了,可以通过此命令取消合并

但是已经合并成功了,通过该命令无法取消合并

#### 合并的原理

三个节点:	当前分支所指向的提交对象节点(**当前节点**),目标分支所指向节点(**目标节点**)和两个分支共同父提交对象节点(**父节点**)

将目标节点到父节点之间的修改,重新提交到当前分支,在当前分支上生成一个新的提交对象,默认生成提交的描述信息,也允许自行修改描述信息

==git merge -m 描述信息==:	可以修改合并提交描述信息

自动合并失败,一般是出现合并冲突,需要人为去解决冲突然后进行提交合并

#### 合并类型

==auto-merge==:   自动合并

==fast-forward==:   快速前移

快速合并出现的场景:	master分支切换到dev分支,在dev分支上进行了修改,但是在master分支没有进行任何修改,切换回master分支,并将dev分支合并到master分支,就是快速前移

可以理解为**当前节点与父节点是同一个节点,所以相对来说没有进行分叉,合并目标分支到当前分支,只是将当前分支指针前移到目标节点**

如果当前节点和父节点不是同一个节点就行自动合并

#### 禁止快速前移

快速前移的不好之处在于无法判断哪些提交是属于当前分支的还是从其他分支合并过来的

命令: ==git merge --no-ff <目标分支>==

禁止快速前移,合并生成一个新的提交对象

### 删除分支

命令:==git branch -d <分支名>==

删除指定分支

注意:  

1. 不能删除HEAD指针所指向的分支
2. 不能删除未合并的分支, git会认为删除未合并分支会丢失修改, 但是如果你确认要删除该分支可以使用==git branch -D <分支名>==命令强行进行删除

## 撤销工作目录文件修改

命令: ==git checkout -- <文件名>== 或 ==git checkout <文件名>==

命令: ==git restore <文件名>==

撤销工作目录指定文件修改

命令: ==git checkout -- . == 或 ==git checkout .==

命令: ==git restore . ==

撤销工作目录下所有文件修改

## 重置

命令: ==git reset==

### 取消暂存

命令: ==git reset <文件名>== 或 ==git reset HEAD <文件名>==

命令: ==git restore --staged <文件名>==

取消指定文件暂存,恢复到工作区

命令: ==git reset . == 或 ==git reset HEAD .==

命令: ==git restore --staged .==

取消所有文件暂存,全部恢复到工作区

### 重置提交

命令: ==git reset HEAD^== 等价于 ==git reset HEAD~1==

将HEAD指针以及HEAD指针所指向的分支指针向前移动一个提交对象,意味着向前回滚了一个git版本

HEAD后的^符号,一个表示向前移动一个提交对象,有多少个就表示向前移动多少个提交对象,也就是向前回滚多少版本

~n符号后面的数字是多少,就表示向前移动多少个提交对象

命令: ==git reset <提交对象的hash值>==

重置到指定hash值的某次提交

#### 重置的参数配置

1. ==git reset --hard ==:  取消暂存,清空工作目录,**慎用会丢失修改**
2. ==git reset --soft==: 将相对于分支指针指向的提交对象的后续提交对象的修改自动添加暂存,保留工作目录
3. ==git reset --mixed==: 取消暂存,将相对于分支指针指向的提交对象的后续提交对象的修改保留在工作区(默认模式)

链接:  [git reset 原理讲解](https://bbs.huaweicloud.com/blogs/331355)

## 存储

命令： ==git stash==

将工作区和暂存区中被git追踪的所有修改文件添加到存储，未被git追踪的文件默认不会被添加到存储

以保证当前工作区和暂存区与最新提交一致

1. ==git stash -u==：将未被git追踪的文件也添加进储存
2. ==git stash save <message>==：添加存储时，添加一个描述信息

### 查看存储列表

命令：==git stash list==

查看所有的存储列表

### 应用存储

命令：==git stash apply==

应用最新的存储，将存储的修改恢复到工作区，**不删除存储**

1. git stash apply ==--index==：恢复存储修改，默认都是恢复到工作区，不管存储前是否添加到暂存区，--index参数允许添加存储的文件原来在暂存区恢复时也在暂存区

命令：==git stash apply <存储id> ==

应用**指定存储**将工作区修改恢复

命令：==git stash pop ==

应用最新的存储，将存储的修改恢复到工作区，**删除相应存储**

命令：==git stash pop <存储id>==

应用**指定存储**将工作区修改恢复，删除相应存储

### 查看存储修改diff

命令：==git stash show==

查看最新存储修改diff，但是只是一个大概版本，只有修改的行数，具体的修改需要使用==git stash show -p==

查看指定存储：==git stash show <存储id>==

### 删除存储

命令：==git stash drop==

删除最新的存储

删除指定存储：==git stash drop <存储id>==

清空存储：==git stash clear==

## 变基

命令： ==git rebase <目标/基点分支>==

在另一个基端之上重新应用提交

名词解释：

1. 目标/基点分支：需要变基到的那个分支，也就是将基点移到该分支的最新提交上
2. 当前/待变基分支：需要进行变基的分支

过程：

1. 找到两个分支的共同祖先提交节点
2. 将待变基分支相对于祖先节点之后的历次提交的修改保存为临时文件
3. 改变待变基分支指向为基点分支指向
4. 取历次提交中的下一次（刚开始是第一次）提交的修改，以当前待变基分支指向为基点进行提交
5. 每一次提交都相当于一次合并过程（递归三路合并），取当前待变基分支指向提交到共同祖先提交的修改与当前提交的修改进行对比合并，如果有冲突，变基暂停解决冲突，然后继续变基
6. 提交成功后，移动待变基分支指针指向新的提交，然后从3继续

可以看出，变基其实是将所有提交重新应用到目标分支上，这时目标分支指向没有变化，还是指向原来那次提交

可以使用merge合并待变基分支进行快速前移

**合并是直接比较两个分支最新的提交对象和祖先提交对象，生成一个commit提交，注重结果**

**变基是当前分支在祖先commit之后的每一次提交都会在目标分支生成一个 commit提交，注重过程，隐式**、

命令：==git rebase --continue==

当变基文件合并遇到冲突时会暂停变基，需要手动解决冲突后，添加到暂存，然后运行该命令通知git继续变基

命令：==git rebase --skip==

当变基文件合并遇到冲突时会暂停变基，可以使用该命令滑过该次提交，也就是说变基成功后不包括该次提交修改

命令：==git rebase --abort==

当变基文件合并遇到冲突时会暂停变基，使用该命令可以取消变基

参考链接：[变基原理](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA)

## 标签

用于给某个提交打上标记，常用于项目的版本控制，表示该提交之前都是属于该版本范围内

### 查看标签

命令：==git tag==

### 创建标签

命令：==git tag <标签名>==

给当前最新提交打上一个标签，标签也是一个指针，用于指向某个提交

1. ==git tag <标签名> <提交hash>==：给指定提交打上标签
2. ==git tag <标签名> -m <备注信息> <提交hash>==：给指定提交打上标签，并给这个标签备注提示

### 删除标签

命令：==git tag -d <标签名>==